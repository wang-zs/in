---
title: "快速排序"
description: "sort"
layout: post
date: 2017-01-27 03:23:44 +0800
categories: [tools]
tags: [sort, jekyll, github]
comments: yes
---
java虚拟机：

根搜索算法：从跟判断是否可达该引用；

引用计数：一个对象被引用计数器加一，取消引用计数器减一，引用计数器为0才能被回收。优点：简单。缺点：不能解决循环引用的问题，比如A引用B，B引用A，但是这两个对象没有被其他任何对象引用，属于垃圾对象，却不能回收；每次引用都会附件一个加减法，影响性能。

标记清除法：分为两个阶段：标记阶段和清除阶段。标记阶段通过根节点标记所有可达对象，清除阶段清除所有不可达对象。缺点：因为清除不可达对象之后剩余的内存不连续，会产生大量内存碎片，不利于大对象的分配。

复制算法：将内存空间分成相同的两块，每次只是用其中的一块，垃圾回收时，将正在使用的内存中的存活对象复制到另外一块空间，然后清除正在使用的内存空间中的所有对象，这种回收算法适用于新生代垃圾回收。优点：垃圾回收对象比较多时需要复制的对象恨少，性能较好；不会存在内存碎片。缺点：将系统内存折半。

标记压缩算法：是一种老年代回收算法，在标记清除的基础上做了一些优化，首先从根节点开始标记所有不可达的对象，然后将所有可达的对象移动到内存的一端，最后清除所有不可达的对象。优点：不用将内存分为两块；不会产生内存碎片。

分代算法：新生代使用复制算法，老生带使用标记清除算法或者标记压缩算法。几乎所有的垃圾回收期都区分新生代和老生带。

分区算法：将整个堆空间分成很多个连续的不同的小空间，每个小空间独立使用，独立回收。为了更好的控制gc停顿时间，可以根据目标停顿时间合理地回收若干个小区间，而不是整个堆空间，从而减少gc停顿时间。



内存够用时，保留对象；内存紧张时丢弃。

强引用： new
软引用： SoftReference
弱引用:  Weak
虚引用:  Phantom

强引用：你懂的，不要胡乱持有着不放，不然内存泄露、oom有你好看
软引用：内存不足时引用对象可被虚拟机回收，但是system.gc对其无效
弱引用：同软引用，在对象没有其他引用的情况下，调用system.gc对象可被虚拟机回收
虚引用：就只是一个标识，对象的生命周期不受期影响


thread 还是 runnable ：http://developer.51cto.com/art/201203/321042.htm

锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）

解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。

　　通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。
　　String str = new String("hello");
　　上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量放在静态区。

　　补充：较新版本的Java（从Java 6的某个更新开始）中使用了一项叫"逃逸分析"的技术，可以将一些局部对象放在栈上以提升对象的操作性能。




